.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "SMITHYFORMULA" "5" "May 2015" "" ""
.
.SH "NAME"
\fBsmithyformula\fR \- writing formulas for smithy
.
.SH "DESCRIPTION"
The main goal of formulas is to consolidate all knowledge required to build a software package\. This can include:
.
.IP "\(bu" 4
defining dependencies
.
.IP "\(bu" 4
loading or swapping modules
.
.IP "\(bu" 4
setting environment variables
.
.IP "\(bu" 4
applying patches
.
.IP "\(bu" 4
creating or changing makefiles
.
.IP "\(bu" 4
running the compilation
.
.IP "\(bu" 4
running tests
.
.IP "\(bu" 4
defining a modulefile
.
.IP "" 0
.
.P
Once written it\'s easy to see everything required to build a given piece of software\. Reproducing those steps is as simple as running one command but only if the formula is as complete as possible\.
.
.P
It\'s common for build scripts to run the compilation but omit patches, changes to makefile, or any other modification to the source\. With formulas it\'s easy to make patches and output any files needed to compile software\.
.
.SH "CREATING NEW FORMULAS"
The best way to create a new formula is to start with a working example\. There are many complete working examples in the smithy_formulas repo \fIhttps://github\.com/AnthonyDiGirolamo/smithy_formulas\fR\.
.
.P
If you want to create a new formula from scratch you can use the \fBsmithy formula new\fR subcommand\. For more info on this command run \fBsmithy help formula new\fR\. To create a new formula file you need to know the homepage and a url to download the file\. To create a new formula for subversion you might run:
.
.IP "" 4
.
.nf

smithy formula new \e
  \-\-name=subversion \e
  \-\-homepage=http://subversion\.apache\.org/ \e
  http://mirror\.cogentco\.com/pub/apache/subversion/subversion\-1\.7\.8\.tar\.bz2
.
.fi
.
.IP "" 0
.
.P
The format of the new sub\-command is \fBsmithy formula new [command options] URL\fR\. The options and arguments are:
.
.TP
\fB\-\-name\fR
This is the name used for the formula file and class, if omitted smithy will try to guess the name based on the download URL
.
.TP
\fB\-\-homepage\fR
This should be the main homepage for the software
.
.TP
\fBURL\fR
A download URL for the software, this argument is required but may be "none" if you plan to checkout the code through a version control system or copy from another location as part of the formula
.
.P
This will create a formula file inside \fB~/\.smithy/formulas\fR or the first formula directory specified in the \fB$SMITHY_CONFIG\fR file\. In either case, the full path to that file will be displayed\.
.
.SH "STRUCTURE"
Formulas attempt to create a domain specific language with the support of a full programming language, ruby\. The structure of a formula is the same as a ruby class\. For example:
.
.IP "" 4
.
.nf

class SubversionFormula < Formula

end
.
.fi
.
.IP "" 0
.
.P
Every method call that defines the formula will happen between these two lines\.
.
.SS "FORMULA FILE AND CLASS NAMING"
Formulas follow a specifc naming scheme\. The filename should end in \fB\'_formula\.rb\'\fR and start with the name of the software in all lowercase characters\. The class name should be the same name specified in the file but CamelCased \fIhttp://en\.wikipedia\.org/wiki/CamelCase\fR and end in \fB\'Formula\'\fR\.
.
.SS "RUBY BASICS"
We will cover most of the basics you need for formula writing here but if you would like more info on ruby you might read through Ruby in Twenty Minutes \fIhttp://www\.ruby\-lang\.org/en/documentation/quickstart/\fR or try another source on the Ruby Documentation \fIhttp://www\.ruby\-lang\.org/en/documentation/\fR page\.
.
.SH "FORMULA DSL METHODS"
These methods should be defined at the highest level of the formula file, right after the \fBclass GitFormula < Formula\fR line\.
.
.SS "homepage"
\fBREQUIRED\fR \- Defines the homepage, e\.g\. "http://git\-scm\.com/"
.
.SS "url"
\fBREQUIRED\fR \- The full URL to download a package, e\.g\. "http://git\-core\.googlecode\.com/files/git\-1\.8\.3\.4\.tar\.gz" may also be "none"
.
.SS "sha1,sha256,md5"
A hash of the downloaded file to verify the download performed correctly, e\.g\. \fBsha1 "fe633d02f7d964842d7ea804278b75120fc60c11"\fR
.
.SS "version"
Manually define the version number, if omitted smithy will guess the version number from the url\. This works best when the filename in a url follows the name\-version\.tar\.\.\. format\. If a url does not follow that format then manually specifying the version with the \fIversion\fR method works best\.
.
.SS "supported_build_names"
This method takes any number of strings or regexes\. When used smithy will check the supplied \fIbuild_name\fR and validate it against what is specified under \fIsupported_build_names\fR\. If the \fIbuild_name\fR does not match a string or regex the install is aborted\.
.
.P
This is useful for when a formula must have specific build names in order to install correctly\. For example, using the this line in a formula:
.
.IP "" 4
.
.nf

supported_build_names "python2\.7", "python3"
.
.fi
.
.IP "" 0
.
.P
And running \fBsmithy formula install python_nose/1\.3\.4/python2\.6\fR (note \fBpython2\.6\fR does not match anything in the \fIsupported_build_names\fR line above)\. Then smithy will output the following abort the install:
.
.IP "" 4
.
.nf

==> PythonNoseFormula supported build names:
  python2\.7
  python3
==> ERROR: use a build_name that includes any of the above patterns
.
.fi
.
.IP "" 0
.
.P
When using strings with \fIsupported_build_names\fR smithy will check to see if the \fIbuild_name\fR contains any supplied substrings\.
.
.P
If using regexes they must simply match the build name\. Here is an example using regexes:
.
.IP "" 4
.
.nf

supported_build_names /python\.*gnu/
.
.fi
.
.IP "" 0
.
.P
That regex checks for \fBpython\fR followed by any number of characters followed by \fBgnu\fR\. When running \fBsmithy formula install python_numpy/1\.9\.2/python2\.7\.9\fR with the above you should see:
.
.IP "" 4
.
.nf

==> PythonNumpyFormula supported build names:
  python\.*gnu
==> ERROR: use a build_name that includes any of the above patterns
.
.fi
.
.IP "" 0
.
.SS "params"
This method is used to specify some unchanging variables you would like to use in any block throughout the formula\. It can be useful if you want some variables located at the top of the formula file that are easily changed\. It takes a hash where the keys are variable names and the values are the variable contents\. For example:
.
.IP "" 4
.
.nf

class ExampleFormula do
  homepage "http://example\.com"
  url "http://example\.com/example\-1\.2\.3\.tar\.gz"

  params example_api_version: "1\.0",
         build_folder: "example1\.0"

  def install
    system "\./configure \-\-api\-version #{example_api_version} \-\-build\-dir #{build_folder}"
  end
end
.
.fi
.
.IP "" 0
.
.SS "concern for_version(\"1\.2\.3\") do"
Concerns are used allow formulas to support multiple versions\. When used, their contents will override the same methods defined at the root level of a formula class\. They are a part of the ActiveSupport Concerning Module \fIhttp://api\.rubyonrails\.org/classes/Module/Concerning\.html\fR
.
.P
To specify a concern for version 1\.2\.3 of a package add the following to a formula (replacing the comment with the methods you would like to override)\.
.
.IP "" 4
.
.nf

concern for_version("1\.2\.3") do
  included do
    # override methods here
  end
end
.
.fi
.
.IP "" 0
.
.P
Anything formula DSL method can be overridden including \fIdef install\fR\.
.
.P
Here is an example of a python formula that supports version \fB2\.7\.9\fR and \fB3\.4\.3\fR\. The concern only overrides the download urls and md5s\.
.
.IP "" 4
.
.nf

class PythonFormula < Formula
  homepage "www\.python\.org/"

  depends_on "sqlite"

  module_commands ["unload python"]

  concern for_version("2\.7\.9") do
    included do
      url "https://www\.python\.org/ftp/python/2\.7\.9/Python\-2\.7\.9\.tgz"
      md5 "5eebcaa0030dc4061156d3429657fb83"
    end
  end

  concern for_version("3\.4\.3") do
    included do
      url "https://www\.python\.org/ftp/python/3\.4\.3/Python\-3\.4\.3\.tgz"
      md5 "4281ff86778db65892c05151d5de738d"
    end
  end

  def install
    module_list
    ENV["CPPFLAGS"] = "\-I#{sqlite\.prefix}/include"
    ENV["LDFLAGS"]  = "\-L#{sqlite\.prefix}/lib"
    system "\./configure \-\-prefix=#{prefix} \-\-enable\-shared"
    system "make"
    system "make install"
  end
end
.
.fi
.
.IP "" 0
.
.P
Using the above formula it is possible to install python with the following and smithy will download the correct tarball for each version:
.
.IP "" 4
.
.nf

smithy formula install python/2\.7\.9/sles11\.3_gnu4\.3\.4
smithy formula install python/3\.4\.3/sles11\.3_gnu4\.3\.4
.
.fi
.
.IP "" 0
.
.SS "disable_group_writable"
Calling this method within the formula will skip setting group writable file permissions after the build is complete\. It\'s equivalent to running smithy with the \fB\-\-disable\-group\-writable\fR option\. See \fBsmithy help\fR for more info on global command line options\.
.
.SS "depends_on"
This method expects either a single string or an array of strings that define dependencies for this formula\. e\.g\.
.
.IP "" 4
.
.nf

depends_on "curl"
depends_on [ "cmake", "qt", "openssl", "sqlite" ]
depends_on %w{ cmake qt openssl sqlite }
.
.fi
.
.IP "" 0
.
.P
Using this method ensures that if a given dependency is not met smithy will abort the installation\. It also provides a way to query dependent packages information within the install method later on\. For example if you write \fBdepends_on "curl"\fR in your formula you gain access to an object named curl inside the install method\. This allows you to do things like:
.
.IP "" 4
.
.nf

system "\./configure \-\-prefix=#{prefix} \-\-with\-curl=#{curl\.prefix}"
.
.fi
.
.IP "" 0
.
.P
In the above example \fB#{curl\.prefix}\fR is an example of a ruby interpolated string, everything between the \fB#{ }\fR is ruby code\. \fBcurl\.prefix\fR will return a string with the location curl is installed in\.
.
.P
The strings passed to \fBdepends_on\fR are just the locations of installed software\. If you required a specific version of a dependency you could use specify the version or build numbers of existing installed software\. e\.g\.
.
.IP "" 4
.
.nf

depends_on [ "cmake/2\.8\.11\.2/sles11\.1_gnu4\.3\.4", "qt/4\.8\.5", "sqlite" ]
.
.fi
.
.IP "" 0
.
.P
Assuming your software root is \fB/sw/xk6\fR smithy would look for the above software installs in \fB/sw/xk6/cmake/2\.8\.11\.2/sles11\.1_gnu4\.3\.4\fR \fB/sw/xk6/qt/4\.8\.5/*\fR and \fB/sw/xk6/sqlite/*/*\fR\. The \fB*\fR works similar to shell globbing\. If you needed to install a python module that depends on a specific version of another python module you might use:
.
.IP "" 4
.
.nf

depends_on [ "python/3\.3\.0", "python_numpy/1\.7\.1/*python3\.3\.0*" ]
.
.fi
.
.IP "" 0
.
.P
This would require a given formula to have access to both \fB/sw/xk6/python/3\.3\.0/*\fR and a python module with a build name that includes \fBpython3\.3\.0\fR located at \fB/sw/x6/python_numpy/1\.7\.1/*python3\.3\.0*\fR
.
.P
You will also probably need to specifiy dependencies conditionally upon the type of build you are performing\. It\'s recommended to add the type of build to the build name when installing\. Given that, you can key off build names to specify dependencies\. Taking the python example further, lets extend it to support multiple versions of python\. You can pass a ruby block to the \fBdepends_on\fR method to make it more dynamic\. The syntax for this is:
.
.IP "" 4
.
.nf

depends_on do
  \.\.\.
end
.
.fi
.
.IP "" 0
.
.P
Any ruby code may go in here the last executed line of the block should be an array of strings containting the dependencies\. Lets use a ruby case statement for this:
.
.IP "" 4
.
.nf

depends_on do
  case build_name
  when /python3\.3/
    [ "python/3\.3\.0", "python_numpy/1\.7\.1/*python3\.3\.0*" ]
  when /python2\.7/
    [ "python/2\.7\.3", "python_numpy/1\.7\.1/*python2\.7\.3*" ]
  end
end
.
.fi
.
.IP "" 0
.
.P
In this example case statement switches on the \fBbuild_name\fR\. The \fBwhen /python3\.3/\fR will be true if the \fBbuild_name\fR contains the \fBpython3\.3\fR\. The \fB/python3\.3/\fR syntax is a regular expression\.
.
.P
This allows the formula to set it\'s dependencies based off the type of build thats being performed\. Lets say this formula is \fBpython_matplotlib\fR\. You could run either of these commands to install it and expect the dependencies to be set correctly:
.
.IP "" 4
.
.nf

smithy formula install python_matplotlib/1\.2\.3/python3\.3\.0
smithy formula install python_matplotlib/1\.2\.3/python2\.7\.3
.
.fi
.
.IP "" 0
.
.SS "module_commands"
This method defines the module commands that must be run before \fIsystem\fR calls within the \fIdef install\fR part of the modulefile\. It expects an array of strings with each string being a module command\. e\.g\.
.
.IP "" 4
.
.nf

module_commands [ "load szip", "load hdf5" ]
.
.fi
.
.IP "" 0
.
.P
A more complicated example:
.
.IP "" 4
.
.nf

module_commands [
  "unload PE\-gnu PE\-pgi PE\-intel PE\-cray",
  "load PE\-gnu",
  "load cmake/2\.8\.11\.2",
  "load git",
  "swap gcc gcc/4\.7\.1",
  "swap ompi ompi/1\.6\.3"
]
.
.fi
.
.IP "" 0
.
.P
\fBmodule_commands\fR also accepts ruby blocks the syntax for this is:
.
.IP "" 4
.
.nf

module_commands do
  \.\.\.
end
.
.fi
.
.IP "" 0
.
.P
This can be used to dynamically set which modules to load based on the \fBbuild_name\fR\. Here is an example that loads the correct python version:
.
.IP "" 4
.
.nf

module_commands do
  commands = [ "unload python" ]

  case build_name
  when /python3\.3/
    commands << "load python/3\.3\.0"
  when /python2\.7/
    commands << "load python/2\.7\.3"
  end

  commands << "load python_numpy"
  commands << "load szip"
  commands << "load hdf5/1\.8\.8"
  commands
end
.
.fi
.
.IP "" 0
.
.P
This block starts by creating a variable named \fBcommands\fR as an array with a single item \fB"unload python"\fR\. Next a case statement is used to determine which version of python we are compiling for\. \fBcommands << "load python/3\.3\.0"\fR will append \fB"load python/3\.3\.0"\fR to the end of the array\. See the ruby documentation on the Array Class method \fIhttp://www\.ruby\-doc\.org/core\-2\.0/Array\.html#method\-i\-3C\-3C\fR for more info on the \fB<<\fR operator\. After that, it appends a few more modules to load\. The last line of the block must be the array itself so that when the block is evaluated by smithy, it recieves the expected value\.
.
.P
Assuming this is a formula for \fBpython_h5py\fR running \fBsmithy formula install python_h5py/2\.1\.3/python3\.3\fR results in an array containing: \fB[ "unload python", "load python/3\.3\.0", "load python_numpy", "load szip", "load hdf5/1\.8\.8" ]\fR
.
.SS "modules"
This command is similar to the \fImodule_commands\fR method\. It accepts an array of strings with the names of modulefiles that must be loaded\. It\'s different from \fImodule_commands\fR in that it expects only names of modules and loads them in the order specified\. Additionally it runs a \fBmodule purge\fR to unload all modules before loading the passed array of modules\. e\.g\.
.
.IP "" 4
.
.nf

modules [ "java" ]
.
.fi
.
.IP "" 0
.
.P
This line would run \fBmodule purge\fR and \fBmodule load java\fR before any \fIsystem\fR command\. \fImodules\fR also accepts ruby blocks similar to \fImodule_commands\fR and \fIdepends_on\fR\. Here is an example using ruby blocks:
.
.P
modules do
.
.IP "" 4
.
.nf

mods = [ ]
case build_name
when /gnu/
  mods << "PrgEnv\-gnu"
when /pgi/
  mods << "PrgEnv\-pgi"
when /intel/
  mods << "PrgEnv\-intel"
when /cray/
  mods << "PrgEnv\-cray"
end
mods
.
.fi
.
.IP "" 0
.
.P
end
.
.P
This block would result in the formula running \fBmodule purge\fR followed by \fBmodule load PrgEnv\-gnu\fR if the \fBbuild_name\fR contains gnu and similarly for pgi, intel, and cray\.
.
.SS "modulefile"
This method expects the a string that represents the modulefile\. Generally modulefiles in smithy take two forms ones that point to a single build and ones that use multiple builds and set the build based on a users environment (already loaded modules)\. It\'s recommended to have one modulefile per application version and set multiple builds dynamically inside the modulefile\.
.
.P
Writing modulefiles is a topic in and of itself\. For details on the modulefile format see the modulefile(4) manpage \fIhttp://modules\.sourceforge\.net/man/modulefile\.html\fR Modulefiles are written in tcl and can take many forms\.
.
.P
Here is an example of a modulefile that points to a single build\. It\'s convenient to use heredoc string quoting in ruby so that the string can span multiple lines\. e\.g\.
.
.IP "" 4
.
.nf

modulefile <<\-MODULEFILE\.strip_heredoc
  #%Module
  proc ModulesHelp { } {
     puts stderr "<%= @package\.name %> <%= @package\.version %>"
     puts stderr ""
  }
  module\-whatis "<%= @package\.name %> <%= @package\.version %>"

  set PREFIX <%= @package\.prefix %>

  prepend\-path PATH            $PREFIX/bin
  prepend\-path LD_LIBRARY_PATH $PREFIX/lib
  prepend\-path MANPATH         $PREFIX/share/man
MODULEFILE
.
.fi
.
.IP "" 0
.
.P
The \fB<<\-MODULEFILE\.strip_heredoc\fR syntax denotes the beginning for a multi\-line string\. The string ends with \fBMODULEFILE\fR\. You can substitute any word for \fBMODULEFILE\fR\. The \fB\.strip_heredoc\fR method removes leading whitespace from the string so the output isn\'t unecessarily indented\.
.
.P
The modulefile definition uses the erb format \fIhttp://ruby\-doc\.org/stdlib\-2\.0/libdoc/erb/rdoc/ERB\.html\fR Anything between the \fB<%= \.\.\. %>\fR delimiters will be interpreted as ruby code\. There are a few helper methods that you can use inside these delimiters see the next section titled [MODULEFILE HELPER METHODS][] for details\.
.
.P
A more complicated modulefile may examine already loaded modules to determine which build to load\. For instance if the user has gcc or a gnu programming environment module loaded then your modulefile will want to load the gnu build\. Here is an example designed to dynamically set the build:
.
.IP "" 4
.
.nf

#%Module
proc ModulesHelp { } {
   puts stderr "<%= @package\.name %> <%= @package\.version %>"
   puts stderr ""
}
# One line description
module\-whatis "<%= @package\.name %> <%= @package\.version %>"

<% if @builds\.size > 1 %>
<%= module_build_list @package, @builds %>

set PREFIX <%= @package\.version_directory %>/$BUILD
<% else %>
set PREFIX <%= @package\.prefix %>
<% end %>

# Helpful ENV Vars
setenv <%= @package\.name\.upcase %>_DIR $PREFIX
setenv <%= @package\.name\.upcase %>_LIB "\-L$PREFIX/lib"
setenv <%= @package\.name\.upcase %>_INC "\-I$PREFIX/include"

# Common Paths
prepend\-path PATH            $PREFIX/bin
prepend\-path LD_LIBRARY_PATH $PREFIX/lib
prepend\-path MANPATH         $PREFIX/share/man
prepend\-path INFOPATH        $PREFIX/info
prepend\-path PKG_CONFIG_PATH $PREFIX/lib/pkgconfig
prepend\-path PYTHONPATH      $PREFIX/lib/python2\.7/site\-packages
prepend\-path PERL5PATH       $PREFIX/lib/perl5/site_perl
.
.fi
.
.IP "" 0
.
.P
The main difference from the first example is the \fB<%= if @builds\.size > 1 %>\fR block\. This basically checks to see if we have installed multiple builds or not\. If that condition is true everything up until the \fB<% else %>\fR will be put in the modulefile\. Otherwise, if we have only one build, \fBset PREFIX <%= @package\.prefix %>\fR will be put in the modulefile\.
.
.SS "def install"
\fBREQUIRED\fR \- This is the method that runs the software installation process\. It normally runs system commands, performs patches, and sets environment variables\. e\.g\.
.
.IP "" 4
.
.nf

def install
  system "\./configure"
  system "make"
  system "make install"
end
.
.fi
.
.IP "" 0
.
.P
The contents of the install method depends heavily on the software being installed\. For a list of additional helper methods for use inside install see the [FORMULA HELPER METHODS][] section\.
.
.SS "additional_software_roots"
This method takes an array of strings (or a block that returns an array of strings) containing paths to additional software root directories\. This is useful for when you have a package that must be installed to two or more separate locations\. The source is still extracted to one location and the compilation is performed there\. The \fIdef install\fR method is just executed again with the additional prefixes\. For example say our formula contained the line:
.
.IP "" 4
.
.nf

additional_software_roots ["/lustre/atlas/sw"]
.
.fi
.
.IP "" 0
.
.P
Then when we run \fBsmithy formula install python_numpy/1\.9\.2/python2\.7\.9\fR then python will still be installed to the default prefix of \fB/sw/xk6/python_numpy/1\.9\.2/python2\.7\.9\fR It will also get installed to \fB/lustre/atlas/sw/xk6/python_numpy/1\.9\.2/python2\.7\.9\fR
.
.P
You can combine this with \fIconfig_value\fR to generalize you formulas further\. Say we always need to know where software gets installed on the lustre filesystem\. We can add this line to the config file: \fBlustre\-filesystem: /lustre/atlas/sw\fR and in out formulas say:
.
.IP "" 4
.
.nf

additional_software_roots [ config_value("lustre\-filesystem") ]
.
.fi
.
.IP "" 0
.
.SH "FORMULA HELPER METHODS"
These methods are designed to be used within the \fIdef install\fR method of a formula file or within a block passed to one [FORMULA DSL METHODS][]\.
.
.SS "name"
This will return the name of the application being installed\. It is the same as the APPLICATION part of the smithy formula install APPLICATION/VERSION/BUILD command\. It can be used as a variable as well as inside of a string using the \fB#{ \.\.\. }\fR delimiters\. e\.g\. \fB"#{name}"\fR
.
.SS "version"
Similar to the above, this returns the version number\.
.
.SS "build_name"
Same as the name and version methods, this will return the build name of the applcation\.
.
.SS "prefix"
This line will return the full prefix to an application\. If we run smithy formula install bzip2/1\.0\.4/pgi13\.4 and our software\-root is /sw/xk6 this command will return /sw/xk6/bzip2/1\.0\.4/pgi13\.4
.
.SS "hostname"
This method will return the hostname of the machine smithy is running on\.
.
.SS "arch"
This method will return the current architecture specified in the config file for the current hostname\. For example if the config file contains:
.
.IP "" 4
.
.nf

\-\-\-
software\-root: /sw
file\-group\-name: ccsstaff
hostname\-architectures:
  titan\-ext: xk6
  titan\-login: xk6
.
.fi
.
.IP "" 0
.
.P
And you run smithy on \fBtitan\-ext1\fR then \fBarch\fR will return \fBxk6\fR
.
.SS "cray_linux_version"
If smithy is running on a cray system this method will return the Cray Linux Environment version\. Otherwise it will return false\.
.
.SS "cray_system?"
This method will return true if smithy is running on a cray system\.
.
.SS "config_value"
This method lets you retrieve arbitrary values from the \fB$SMITHY_CONFIG\fR file\. Since that file is in YAML \fIhttp://yaml\.org/\fR format you can easily append extra values for use in your formulas\.
.
.P
For example, if your system has a specific path for a filesystem your formula needs to know about then you can add it you the config file\. Say we add a line titled \fBlustre\-filesystem\fR:
.
.IP "" 4
.
.nf

\-\-\-
software\-root: /sw
file\-group\-name: ccsstaff
hostname\-architectures:
  titan\-ext: xk6
  titan\-login: xk6
lustre\-filesystem: /lustre/atlas/sw
.
.fi
.
.IP "" 0
.
.P
You can then call \fBconfig_value("lustre\-filesystem")\fR in your formulas and get \fB/lustre/atlas/sw\fR back\.
.
.SS "system"
This method accepts a string or multiple strings separated by commas\. It will run the given command in a subshell and setup the modules as defined by the \fImodule_commands\fR or \fImodules\fR methods\. Each call to system is independent from the last\. Modules are reloaded and environment variables are reset\.
.
.SS "system_python"
The \fIsystem_python\fR method runs \fBpython\fR using a \fIsystem\fR command and sets the \fBPYTHONPATH\fR environment variable to a location in the current \fIprefix\fR\. This is useful for running a \fBsetup\.py\fR for a python module\. It is designed to be used like:
.
.IP "" 4
.
.nf

system_python "setup\.py install \-\-prefix=#{prefix} \-\-compile"
.
.fi
.
.IP "" 0
.
.P
Under the hood it is running:
.
.IP "" 4
.
.nf

system "PYTHONPATH=$PYTHONPATH:#{prefix}/lib/#{python_libdir(current_python_version)}/site\-packages python",
  "setup\.py install \-\-prefix=#{prefix} \-\-compile"
.
.fi
.
.IP "" 0
.
.P
Where \fBpython_libdir(current_python_version)\fR is the lib directory for the version of python in the \fB$PATH\fR e\.g\. \fBpython2\.7\fR or \fBpython3\.4\fR
.
.SS "python_module_from_build_name"
This is a helper to change a full python version specified in the \fIbuild_name\fR e\.g\. \fBpython2\.7\.9\fR or \fBpython3\.4\.3\fR to a version with a forward slash e\.g\. \fBpython/2\.7\.9\fR or \fBpython/3\.4\.3\fR respectively\.
.
.P
It is useful for when a formula is installed with a python version in the \fIbuild_name\fR and you want to get the corresponding python version string for use in a \fImodule_commands\fR or \fIdepends_on\fR block\. For example:
.
.IP "" 4
.
.nf

depends_on do
  python_module_from_build_name
end

module_commands do
  [ "unload python",
    "load #{python_module_from_build_name}" ]
end
.
.fi
.
.IP "" 0
.
.P
If the above is used when installing a formula with \fBpython2\.7\.9\fR in the build name e\.g\. \fBsmithy formula install python_numpy/1\.9\.2/python2\.7\.9_gnu4\.8\.2\fR then \fIpython_module_from_build_name\fR will return \fBpython/2\.7\.9\fR\.
.
.SS "python_version_from_build_name"
Like \fIpython_module_from_build_name\fR, this is a helper to extract the python version from the \fIbuild_name\fR\. It is useful when a formula is installed with a python version in the \fIbuild_name\fR and you want to get the corresponding python version string for use in a \fIdepends_on\fR block\. For example:
.
.IP "" 4
.
.nf

depends_on "python_numpy/1\.9\.2/#{python_version_from_build_name}*"
.
.fi
.
.IP "" 0
.
.P
If the above is used when installing a formula with \fBpython2\.7\.9\fR in the \fIbuild_name\fR e\.g\. \fBsmithy formula install python_scipy/0\.15\.1/python2\.7\.9_gnu4\.8\.2\fR then \fIpython_version_from_build_name\fR will return \fBpython2\.7\.9\fR\.
.
.SS "python_libdir(version)"
This method will extract the major and minor version numbers for the python version being installed\. This is only useful for the python formula \fIhttps://github\.com/AnthonyDiGirolamo/smithy_formulas/blob/master/python_formula\.rb\fR\. It is useful when referencing the python libdir, which is shared among different patch versions\. When installing python/3\.4\.3/sles11\.1_gnu4\.8\.2 the result of \fBpython_libdir(version)\fR will be \fBpython3\.4\fR\.
.
.SS "module_list"
This method will run \fBmodule list\fR and print it\'s output durring the install process\. Useful for verifying the modules loaded are the ones you want\.
.
.SS "module_is_available?"
This method will check if a given modulename is available on the system you are performing the installation on\. It takes one string argument, the module name\. It can be used within the \fIdef install\fR, \fIdepends_on\fR, \fImodule_commands\fR, or \fImodules\fR methods\.
.
.IP "" 4
.
.nf

if module_is_available?("hdf5/1\.8\.8")
  \.\.\.
end
.
.fi
.
.IP "" 0
.
.SS "module_environment_variable"
Using this method will return the contents of an environment varible set by a modulefile\. It takes two string arguments, the module name and the environment variable name\. For example, if you wished to get the value of the \fB$HDF5_DIR\fR variable set within the \fBhdf5/1\.8\.8\fR module you could run:
.
.IP "" 4
.
.nf

hdf5_prefix = module_environment_variable("hdf5/1\.8\.8", "HDF5_DIR")
.
.fi
.
.IP "" 0
.
.P
Using this method to get environment variable set by modules is necessary since the modules are only set before running a \fIsystem\fR command\. See \fISetting Environment Variables\fR for more info\. It can be used within the \fIdef install\fR, \fIdepends_on\fR, \fImodule_commands\fR, or \fImodules\fR methods\.
.
.P
By combining the [module_is_available?][] and \fImodule_environment_variable\fR methods you can conditionally retrieve the contents of environment variables set within a given module\.
.
.IP "" 4
.
.nf

if module_is_available?("hdf5/1\.8\.8")
  hdf5_prefix = module_environment_variable("hdf5/1\.8\.8", "HDF5_DIR")
end
.
.fi
.
.IP "" 0
.
.SS "patch"
The patch method is a convinience method to apply patches to code\. Behind the scenes it creates a file named \fBpatch\.diff\fR with the passed content and runs \fBpatch \-p1 <patch\.diff\fR\. Using the heredoc syntax works best to strip leading whitespace\. For example:
.
.IP "" 4
.
.nf

patch <<\-EOF\.strip_heredoc
  diff \-\-git a/CMake/cdat_modules/cairo_external\.cmake b/CMake/cdat_modules/cairo_external\.cmake
  index e867fb2\.\.22fb40c 100644
  \-\-\- a/CMake/cdat_modules/cairo_external\.cmake
  +++ b/CMake/cdat_modules/cairo_external\.cmake
  @@ \-1,7 +1,7 @@

   set(Cairo_source "${CMAKE_CURRENT_BINARY_DIR}/build/Cairo")
   set(Cairo_install "${cdat_EXTERNALS}")
  \-set(Cairo_conf_args \-\-disable\-static)
  +set(Cairo_conf_args \-\-enable\-gobject=no \-\-disable\-static)

   ExternalProject_Add(Cairo
     DOWNLOAD_DIR ${CDAT_PACKAGE_CACHE_DIR}
EOF
.
.fi
.
.IP "" 0
.
.P
Any input you provide must be compatible with the patch command\. You can use interpolated strings \fB#{ \.\.\. }\fR to modify the content of patches as well:
.
.IP "" 4
.
.nf

patch <<\-EOF\.strip_heredoc
  diff \-\-git a/Makefile\.in b/Makefile\.in
  new file mode 100644
  index 0000000\.\.1235d4b
  \-\-\- /dev/null
  +++ b/Makefile\.in
  @@ \-0,0 +1,12 @@
  +SHELL = /bin/sh
  +PLAT = LINUX
  +BLLIB = #{acml_prefix}/gfortran64/lib/libacml\.a
  +CBLIB = #{prefix}/lib/libcblas\.a
  +CC = gcc
  +FC = gfortran
  +LOADER = $(FC)
  +CFLAGS = \-O3 \-DADD_
  +FFLAGS = \-O3
  +ARCH = ar
  +ARCHFLAGS = r
  +RANLIB = ranlib
EOF
.
.fi
.
.IP "" 0
.
.SH "PYTHON SPECIFIC HELPERS"
Python module installations require some extra consideration\. To make life a bit easier Smithy provides the following methods\.
.
.IP "\(bu" 4
\fIpython_module_from_build_name\fR
.
.IP "\(bu" 4
\fIpython_version_from_build_name\fR
.
.IP "\(bu" 4
\fIpython_libdir(version)\fR
.
.IP "\(bu" 4
\fIsystem_python\fR
.
.IP "\(bu" 4
\fI\fB<%= python_module_build_list @package, @builds %>\fR\fR
.
.IP "" 0
.
.SH "MODULEFILE HELPER METHODS"
.
.SS "<code><%= @package\.name %></code>"
This will return the name of the application being installed\. It is the same as the APPLICATION part of the \fBsmithy formula install APPLICATION/VERSION/BUILD\fR command\.
.
.SS "<code><%= @package\.version %></code>"
Similar to the above, this returns the version number\.
.
.SS "<code><%= @package\.build_name %></code>"
Same as the name and version methods, this will return the build name of the applcation\.
.
.SS "<code><%= @package\.prefix %></code>"
This line will return the full prefix to an application\. If we run \fBsmithy formula install bzip2/1\.0\.4/pgi13\.4\fR and our software\-root is \fB/sw/xk6\fR this command will return \fB/sw/xk6/bzip2/1\.0\.4/pgi13\.4\fR
.
.SS "<code><%= @builds %></code>"
The \fB@builds\fR variable is an array of strings that contain the list of available builds for a given application\. Say we have a bzip2 formula and ran the following installs:
.
.IP "" 4
.
.nf

smithy formula install bzip2/1\.0\.4/gnu4\.3\.4
smithy formula install bzip2/1\.0\.4/gnu4\.7\.2
smithy formula install bzip2/1\.0\.4/pgi13\.4
smithy formula install bzip2/1\.0\.4/intel12
.
.fi
.
.IP "" 0
.
.P
The directory structure for the above builds would look like (assuming \fB/sw/xk6\fR is the software\-root):
.
.IP "" 4
.
.nf

/sw/xk6/bzip2/1\.0\.4
`\-\-\- modulefile
|  `\-\-\- bzip2
|     `\-\-\- 1\.0\.4
`\-\-\- gnu4\.3\.4
|  `\-\-\- bin
|  `\-\-\- include
|  `\-\-\- lib
|  `\-\-\- source
|  `\-\-\- share
`\-\-\- gnu4\.7\.2
|  `\-\-\- bin
|  `\-\-\- include
|  `\-\-\- lib
|  `\-\-\- source
|  `\-\-\- share
`\-\-\- pgi13\.4
|  `\-\-\- bin
|  `\-\-\- include
|  `\-\-\- lib
|  `\-\-\- source
|  `\-\-\- share
`\-\-\- intel12
   `\-\-\- bin
   `\-\-\- include
   `\-\-\- lib
   `\-\-\- source
   `\-\-\- share
.
.fi
.
.IP "" 0
.
.P
The \fB@builds\fR array would then be \fB[ "gnu4\.3\.4", "gnu4\.7\.2", "pgi13\.4", "intel12" ]\fR\. This lets you figure out what builds exist and use them in your modulefile\.
.
.SS "<code><%= @builds\.size %></code>"
size \fIhttp://ruby\-doc\.org/core\-2\.0/Array\.html#method\-i\-size\fR is a standard ruby method that counts the number of elements in an array\. For the above example this would return \fB4\fR\.
.
.SS "<code><%= module_build_list @package, @builds %></code>"
This is a helper method that will generate the tcl necessary to conditionally load builds based on what compiler programming environment modules a user has loaded\. It takes \fB@package\fR and \fB@builds\fR as arguments\. Using the above bzip2 example the result of using this method would be:
.
.IP "" 4
.
.nf

if [ is\-loaded PrgEnv\-gnu ] {
  if [ is\-loaded gcc/4\.3\.4 ] {
    set BUILD gnu4\.3\.4
  } elseif [ is\-loaded gcc/4\.7\.2 ] {
    set BUILD gnu4\.7\.2
  } else {
    set BUILD gnu4\.7\.2
  }
} elseif [ is\-loaded PrgEnv\-pgi ] {
  set BUILD pgi13\.4
} elseif [ is\-loaded PrgEnv\-intel ] {
  set BUILD intel12
} elseif [ is\-loaded PrgEnv\-cray ] {
  puts stderr "Not implemented for the cray compiler"
}
if {![info exists BUILD]} {
  puts stderr "[module\-info name] is only available for the following environments:"
  puts stderr "gnu4\.3\.4"
  puts stderr "gnu4\.7\.2"
  puts stderr "intel12"
  puts stderr "pgi13\.4"
  break
}
.
.fi
.
.IP "" 0
.
.SS "<code><%= python_module_build_list @package, @builds %></code>"
This method is similar to the previously mentioned [module_build_list][] except that it will create a block specific to python versions\. It requires that a full python version be part of the current build name e\.g\. \fBpython2\.7\.9\fR\. It will look at the builds installed for the current formula and create a corresponding tcl if block\. It will also check to see if python modules exist that correspond to the build names\.
.
.P
For example, lets assume we perform the following installs for the python_numpy \fIhttps://github\.com/AnthonyDiGirolamo/smithy_formulas/blob/master/python_numpy_formula\.rb\fR formula:
.
.IP "" 4
.
.nf

smithy formula install python_numpy/1\.9\.2/python2\.7\.9_gnu4\.8\.2
smithy formula install python_numpy/1\.9\.2/python3\.4\.3_gnu4\.8\.2
.
.fi
.
.IP "" 0
.
.P
Then the following builds will exist:
.
.IP "" 4
.
.nf

python_numpy
`\-\-\- 1\.9\.2
   `\-\-\- python2\.7\.9_gnu4\.8\.2
   `\-\-\- python3\.4\.3_gnu4\.8\.2
.
.fi
.
.IP "" 0
.
.P
If the \fBpython/2\.7\.9\fR and \fBpython/3\.4\.3\fR modules exist then [python_module_build_list][] method will create the following output:
.
.IP "" 4
.
.nf

if [ is\-loaded python/2\.7\.9 ] {
  set BUILD python2\.7\.9_gnu4\.8\.2
  set LIBDIR python2\.7
} elseif [ is\-loaded python/3\.4\.3 ] {
  set BUILD python3\.4\.3_gnu4\.8\.2
  set LIBDIR python3\.4
}
if {![info exists BUILD]} {
  puts stderr "[module\-info name] is only available for the following environments:"
  puts stderr "python/2\.7\.9"
  puts stderr "python/3\.4\.3"
  break
}
.
.fi
.
.IP "" 0
.
.P
It is designed to be used like this:
.
.IP "" 4
.
.nf

<%= python_module_build_list @package, @builds %>
set PREFIX <%= @package\.version_directory %>/$BUILD
.
.fi
.
.IP "" 0
.
.SS "<code><% if \.\.\. %></code>"
This is standard erb ruby code\. Delimiters like \fB<% \.\.\. %>\fR do NOT put their results in the final modulefile, they are only used for control flow\. Delimiters with the extra = sign \fB<%= \.\.\. %>\fR will put their results in the final modulefile\.
.
.P
This is best used to conditionally render content to the modulefile and takes the form:
.
.IP "" 4
.
.nf

<% if @builds\.size > 1 %>
  \.\.\.
<% else %>
  \.\.\.
<% end %>
.
.fi
.
.IP "" 0
.
.P
Where \fB@builds\.size > 1\fR can be any expression which returns true or false\. If the if condition is true then the lines between the if and else will be put in the modulefile, otherwise lines between the else and end will be used\.
.
.SH "COMMON OPERATIONS"
.
.SS "Change Working Directory"
Changing the working directory accomplished by the Dir\.chdir \fIhttp://ruby\-doc\.org/core\-1\.9\.3/Dir\.html#method\-c\-chdir\fR method\. It takes one argument as a string\. It\'s best to always work from the prefix of the installation\. You can concatenate strings using a \fB+\fR sign\.
.
.IP "" 4
.
.nf

Dir\.chdir prefix
Dir\.chdir prefix+"/source"
.
.fi
.
.IP "" 0
.
.SS "Running Shell Commands"
In ruby you can execute any shell command using backtick delimiters\. Commands run using this method will NOT load any required modulefiles\. It will however return the standard output as a string
.
.IP "" 4
.
.nf

`ln \-svf file1 file2`
results = `ln \-svf file1 file2`
.
.fi
.
.IP "" 0
.
.P
If you need modulefiles loaded use the \fIsystem\fR command instead\.
.
.IP "" 4
.
.nf

system "ln \-svf file1 file2"
.
.fi
.
.IP "" 0
.
.P
There are many ruby methods available that are the equivalent of running the shell counterparts\. See the these pages for more info:
.
.IP "\(bu" 4
FileUtils Class \fIhttp://www\.ruby\-doc\.org/stdlib\-2\.0/libdoc/fileutils/rdoc/FileUtils\.html\fR
.
.IP "\(bu" 4
Dir Class \fIhttp://ruby\-doc\.org/core\-1\.9\.3/Dir\.html\fR
.
.IP "\(bu" 4
File Class \fIhttp://www\.ruby\-doc\.org/core\-2\.0/File\.html\fR
.
.IP "" 0
.
.SS "Setting Environment Variables"
Ruby provides the ENV \fIhttp://www\.ruby\-doc\.org/core\-2\.0/ENV\.html\fR hash for accessing and setting environment variables\. Here is an example of setting environment variables:
.
.IP "" 4
.
.nf

ENV["CC"]  = "gcc"
ENV["CXX"] = "g++"
ENV["F77"] = "gfortran"
ENV["F90"] = "gfortran"
ENV["FC"]  = "gfortran"
.
.fi
.
.IP "" 0
.
.P
And getting their values back:
.
.IP "" 4
.
.nf

cppflags = ENV["CPPFLAGS"]
.
.fi
.
.IP "" 0
.
.P
This works with one caveat, you cannot access or modify variables set by modules loaded by the formula\. Modules are loaded and reset before each \fIsystem\fR command\.
.
.P
If you need to access the contents of an evironment variable set by a module use the \fImodule_environment_variable\fR helper method\.
.
.P
If you need to change the contents of an environment variable set by a loaded module you will need to make it part of the system command\. For example, say you loaded the \fBnetcdf\fR module and needed to change the \fB$NETCDF_DIR\fR variable\. You could run any of these:
.
.IP "" 4
.
.nf

system "NETCDF_DIR=/opt/cray/netcdf/4\.2\.0/generic \./configure"
system "export NETCDF_DIR=/opt/cray/netcdf/4\.2\.0/generic ;",
  "\./configure"
system "export NETCDF_DIR=/opt/cray/netcdf/4\.2\.0/generic
  \./configure"
.
.fi
.
.IP "" 0
.
.SS "Creating Files"
Using ruby to create files is simple\. With this and the \fB#{ \.\.\. }\fR delimiters you can add dynamic content to the files you write\. The basic syntax for writing files is:
.
.IP "" 4
.
.nf

File\.open("path/to/file", "w+") do |file|
  file\.write "\.\.\."
end
.
.fi
.
.IP "" 0
.
.P
This syntax uses a ruby block with an argument\. \fBFile\.open("\.\.\.", "w+")\fR passes the file handle to the block as a variable named \fBfile\fR\. Between the \fBdo |file|\fR and \fBend\fR lines is the block\. When ruby reaches the end of the block the file is closed\.
.
.P
The \fB"w+"\fR argument tells ruby to open the file with read\-write and truncate the existing file to zero length or create a new file for reading and writing\. See this page \fIhttp://www\.ruby\-doc\.org/core\-2\.0/IO\.html#method\-c\-new\-label\-IO+Open+Mode\fR for more info on the different modes\.
.
.P
Here is a good example from the mpi4py formula \fIhttps://github\.com/AnthonyDiGirolamo/smithy_formulas/blob/master/python_mpi4py_cray_formula\.rb\fR
.
.IP "" 4
.
.nf

File\.open("mpi\.cfg", "w+") do |f|
  f\.write <<\-EOF\.strip_heredoc
    [cray]
    mpi_dir = /opt/cray/mpt/5\.6\.3/gni/mpich2\-gnu/47
    mpicc   = cc
    mpicxx  = CC
  EOF
end
.
.fi
.
.IP "" 0
.
.P
This will create a new file named "mpi\.cfg" in the current working directory\. If you wanted to make it a bit more dynamic you might wish to set the contents based on an environment variable like this:
.
.IP "" 4
.
.nf

mpidir = module_environment_variable("cray\-mpich2", "CRAY_MPICH2_DIR")
File\.open("mpi\.cfg", "w+") do |f|
  f\.write <<\-EOF\.strip_heredoc
    [cray]
    mpi_dir = #{mpidir}
    mpicc   = cc
    mpicxx  = CC
  EOF
end
.
.fi
.
.IP "" 0
.
.SS "Putting it Together"
You can combine these methods in many ways\. This bit of code is from the uvcdat formula \fIhttps://github\.com/AnthonyDiGirolamo/smithy_formulas/blob/master/uvcdat_formula\.rb\fR and it creates symlinks from an openssl installation into a directory under the uvcdat prefix\.
.
.IP "" 4
.
.nf

Dir\.chdir prefix
openssl_files = %w{
  include/openssl
  lib/pkgconfig/libcrypto\.pc
  lib/pkgconfig/libssl\.pc
  lib/pkgconfig/openssl\.pc
  lib/engines
  lib/libcrypto\.a
  lib/libcrypto\.so
  lib/libcrypto\.so\.1\.0\.0
  lib/libssl\.a
  lib/libssl\.so
  lib/libssl\.so\.1\.0\.0
}
FileUtils\.mkdir_p "Externals/include"
FileUtils\.mkdir_p "Externals/lib/pkgconfig"
openssl_files\.each do |file|
  system "ln \-sf #{openssl\.prefix}/#{file} #{prefix}/Externals/#{file}"
end
.
.fi
.
.IP "" 0
.
.P
It begins by changing the working directory to the installation prefix\. Then, creates an array of strings named \fBopenssl_files\fR containing relative paths to files needing to be symlinked\. It then creates directories that might not exist yet using FileUtils\.mkdir_p \fIhttp://www\.ruby\-doc\.org/stdlib\-2\.0/libdoc/fileutils/rdoc/FileUtils\.html#method\-c\-mkdir_p\fR\. Then it iterates through the \fBopenssl_files\fR array and runs one \fIsystem\fR command per array element\. That system command uses an \fBopenssl\.prefix\fR method that is made available by the \fIdepends_on\fR defined earlier in the formula to get the location of the openssl installation\.
.
.SH "SEE ALSO"
smithy(1)
