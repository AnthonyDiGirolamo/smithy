#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end

@smithy_bin_root = File.expand_path(File.dirname(File.realpath(__FILE__))+ '/../')
$: << File.expand_path(@smithy_bin_root + '/lib')
#require 'ruby-debug'
require 'rubygems'
require 'gli'
require 'English'
require 'open4'
require 'smithy'
include GLI
include Smithy

@system_config_file = 'etc/smithyrc'

@hostname = `hostname`.chomp

sysconfig_path = File.expand_path(File.join(@smithy_bin_root,@system_config_file))
if File.exists? sysconfig_path
  @sysconfig_hash = YAML.load_file(sysconfig_path)
end

version Smithy::VERSION

# GLI Config file method - Unnecessary
# config_file File.expand_path(File.join(@smithy_bin_root,@system_config_file))

if @hostname =~ /(.*)(\d)+/
  @machine = $1
  @arch = @sysconfig_hash[:"hostname-architectures"][@machine]
  @sysconfig_hash[:arch] = @arch
else
  raise "Cannot determine which architecture to build for, please specify using --arch"
end

program_desc 'Smithy will help you build, test, and distribute software with ease.'

desc "Machine architecure to operate on (default: #{@arch})"
arg_name 'NAME'
default_value nil
flag [:arch]

#desc 'Mapping of hostnames to architecure names'
#arg_name 'STRING'
#flag ['hostname-architectures']

desc 'The root level directory for software'
default_value '/sw'
arg_name 'PATH'
flag ['software-root']

desc 'Search currently installed software'
arg_name 'name'
command ['search','s'] do |c|
  c.desc 'Turn autocomplete output on'
  c.switch ['auto-complete']

  c.action do |global_options,options,args|
    swroot = File.join(global_options[:"software-root"], global_options[:arch])
    notice "Searching in #{swroot}"

    # Array of full paths to rebuild scripts
    software = Dir.glob(swroot+"/*/*/*/rebuild").sort

    if options[:"auto-complete"]
      # Format complete options correctly
      software.collect!{|s| s.gsub(/#{swroot}\/(.*)\/rebuild/, $1)}
    end

    if args.empty?
      puts software
    else
      software.select! { |s| s =~ /#{args.first}/ }
      puts software
    end

    notice "#{software.count} Found"
  end
end

desc 'Build software'
long_desc "The software to build may be either the absolute path or simply the name of the software. Version numbers and build names may be appended to the name using the format: NAME/VERSION/BUILD."
arg_name 'path'
command ['build','b'] do |c|
  c.desc 'Build log file name located within the software prefix.'
  c.arg_name 'FILE'
  c.default_value 'build.log'
  c.flag ["build-log-name"]

  c.desc "Disable build logging"
  c.switch ["disable-build-log"]

  c.desc 'Send messages from underlying commands (configure, make, etc) to STDOUT.'
  c.switch [:s, 'send-to-stdout']

  c.action do |global_options,options,args|
    raise "You must supply a package to build" if args.empty?

    args.each do |package|
      p = Package.new(:root => global_options[:"software-root"],
                      :arch => global_options[:arch],
                      :path => package)

      if p.valid?
        p.run_rebuild_script(:disable_logging => options[:"disable-log"],
                             :build_log_name => options[:"build-log-name"],
                             :send_to_stdout => options[:"send-to-stdout"])
      end
    end
  end
end

#desc 'Describe create here'
#arg_name 'Describe arguments to create here'
#command :create do |c|
  #c.desc 'Describe a switch to create'
  #c.switch :s

  #c.desc 'Describe a flag to create'
  #c.default_value 'default'
  #c.flag :f
  #c.action do |global_options,options,args|

    ## Your command logic here

    ## If you have any errors, just raise them
    ## raise "that command made no sense"
  #end
#end

#desc 'Describe copy here'
#arg_name 'Describe arguments to copy here'
#command :copy do |c|
  #c.action do |global_options,options,args|
  #end
#end

pre do |global,command,options,args|
  # Parse a hostname-architectures string on the command line - unnecessary
  # if global[:"hostname-architectures"].class == String
  #   command_line_hostnames = {}
  #   global[:"hostname-architectures"].split(',').each do |entry|
  #     machine_arch = entry.split(':')
  #     command_line_hostnames.merge! Hash[*machine_arch] if machine_arch.count==2
  #   end
  # end
  # puts command_line_hostnames.try(:size)

  # If an architecture was not specified, set it based on the mapped value
  global[:arch] = @arch if global[:arch].nil?

  swroot = File.join(global[:"software-root"], global[:arch])
  raise "The software-root directory #{swroot} is not valid" unless Dir.exist?(swroot)

  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit GLI.run(ARGV)
