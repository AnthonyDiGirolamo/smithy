#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end

# Add the lib dir to the ruby library search path
@smithy_bin_root = File.expand_path(File.dirname(File.realpath(__FILE__))+ '/../')
$: << File.expand_path(@smithy_bin_root + '/lib')

require 'rubygems'
require 'gli'
require 'English'
require 'open4'
require 'rainbow'
require 'smithy'
include GLI
include Smithy

version Smithy::VERSION
@smithy_config_file = 'etc/smithyrc'
# GLI Config file method - Unnecessary
# config_file File.expand_path(File.join(@smithy_bin_root,@smithy_config_file))

program_desc 'Smithy will help you build, test, and distribute software with ease.'

desc "Machine architecure to operate on (default defined in: #{@smithy_bin_root}/#{@smithy_config_file})"
arg_name 'NAME'
default_value nil
flag [:arch]

desc 'The root level directory for software'
default_value '/sw'
arg_name 'PATH'
flag ['software-root']

desc 'Search currently installed software'
arg_name 'name'
command ['search','s'] do |c|
  c.desc 'Turn autocomplete output on'
  c.switch ['auto-complete']

  c.action do |global_options,options,args|
    @software_root = File.join(global_options[:"software-root"], global_options[:arch])
    notice "Searching in #{@software_root}"

    # Array of full paths to rebuild scripts
    software = Dir.glob(@software_root+"/*/*/*/rebuild").sort
    software.collect!{|s| s.gsub(/\/rebuild$/, '')}

    # Format complete options correctly
    software.collect!{|s| s.gsub(/#{@software_root}\//, '')} if options[:"auto-complete"]

    count = 0
    if args.empty?
      puts software
      count += software.count
    else
      args.each do |a|
        result = software.select { |s| s =~ /#{a}/ }
        puts result
        count += result.count
      end
    end

    notice "#{count} Found"
  end
end

desc 'Build software'
long_desc "The software to build may be either the absolute path or the full name of the software. The full name includes version numbers and build names using the format: NAME/VERSION/BUILD."
arg_name 'PATH'
command ['build','b'] do |c|
  c.desc 'Build log file name located within the software prefix.'
  c.arg_name 'FILE'
  c.default_value 'build.log'
  c.flag ["build-log-name"]

  c.desc "Disable build logging"
  c.switch ["disable-build-log"]

  c.desc 'Send messages from underlying commands (configure, make, etc) to STDOUT.'
  c.switch [:s, 'send-to-stdout']

  c.desc 'See what packages will be built but without building them'
  c.switch [:n, 'dry-run']

  c.action do |global_options,options,args|
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    else
      packages = args
    end

    raise "You must supply at least one package to build" if packages.empty?

    packages.each do |package|
      p = Package.new(
        :root => global_options[:"software-root"],
        :arch => global_options[:arch],
        :path => package)

      if p.valid?
        p.run_rebuild_script(
          :disable_logging => options[:"disable-build-log"],
          :build_log_name  => options[:"build-log-name"],
          :dry_run         => options[:"dry-run"],
          :send_to_stdout  => options[:"send-to-stdout"])
      end
    end
  end
end

#desc 'Describe create here'
#arg_name 'Describe arguments to create here'
#command :create do |c|
  #c.desc 'Describe a switch to create'
  #c.switch :s

  #c.desc 'Describe a flag to create'
  #c.default_value 'default'
  #c.flag :f
  #c.action do |global_options,options,args|

    ## Your command logic here

    ## If you have any errors, just raise them
    ## raise "that command made no sense"
  #end
#end

#desc 'Describe copy here'
#arg_name 'Describe arguments to copy here'
#command :copy do |c|
  #c.action do |global_options,options,args|
  #end
#end

pre do |global,command,options,args|
  # Parse a hostname-architectures string on the command line - unnecessary
  # if global[:"hostname-architectures"].class == String
  #   command_line_hostnames = {}
  #   global[:"hostname-architectures"].split(',').each do |entry|
  #     machine_arch = entry.split(':')
  #     command_line_hostnames.merge! Hash[*machine_arch] if machine_arch.count==2
  #   end
  # end
  # puts command_line_hostnames.try(:size)

  load_system_config
  # If an architecture was not specified, set it based on the mapped value
  global[:arch] = get_arch if global[:arch].nil?
  @software_root = get_software_root(:root => global[:"software-root"], :arch => global[:arch])

  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit GLI.run(ARGV)
