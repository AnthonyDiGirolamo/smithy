#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end

# Absolute path to the smithy gem prefix
@@smithy_bin_root = File.expand_path(File.dirname(File.realpath(__FILE__))+ '/../')
# Add the smithy lib dir to the ruby library search path
$: << File.expand_path(@@smithy_bin_root + '/lib')

require 'rubygems'
require 'gli'
require 'English'
require 'open4'
require 'rainbow'
require 'readline'
require 'terminal-table'
require 'erb'
require 'smithy'

include GLI
include Smithy

version Smithy::VERSION

# Absolute path to the smithy config file
@smithy_config_file = File.join(@@smithy_bin_root,"etc/smithyrc")

program_desc "Smithy will help you build, test, and distribute software with ease."

desc "Machine architecure to operate on"
arg_name "NAME"
flag [:arch]

desc "Group name for files created by smithy"
arg_name "GROUP"
flag ["file-group-name"]

desc "Disable group writable file creation"
switch ["disable-group-writable"]

desc "The root level directory for software"
arg_name "PATH"
flag ["software-root"]

desc "The root level directory for web files"
arg_name "PATH"
flag ["web-root"]

desc "Don't use colors"
switch "no-color"

desc "Alternate config file (default: #{@smithy_config_file})"
arg_name "FILE"
flag [:"config-file"]

desc "Search currently installed software"
arg_name "PATTERN"
command ['search'] do |c|
  output_formats = {
    'path'  => Smithy::Format::Path.new,
    'name'  => Smithy::Format::Name.new,
    'table' => Smithy::Format::Table.new,
    'csv'   => Smithy::Format::CSV.new
  }
  c.desc 'Format of the output'
  c.arg_name output_formats.keys.join('|')
  c.default_value output_formats.keys.first
  c.flag :format

  #sorting = %w{name date user}
  #c.desc 'Field to sort in ascending order'
  #c.arg_name sorting.join('|')
  #c.default_value sorting.first
  #c.flag :sort

  c.action do |global_options,options,args|
    swroot = global_options[:full_software_root_path]

    formatter = output_formats[options[:format]]
    raise "Unknow format \"#{options[:format]}\" valid formats include: #{output_formats.keys.join(',')}" if formatter.nil?

    notice "Searching in #{swroot}"

    software = Package.all :root => swroot

    count = 0
    formatter.before
    if args.empty?
      formatter.format(software, swroot)
      count += software.count
    else
      args.each do |a|
        result = software.select { |s| s =~ /#{a}/ }
        formatter.format(result, swroot)
        count += result.count
      end
    end
    formatter.after

    notice "#{count} Found"
  end
end

desc "Build software"
long_desc "The software to build may be either the absolute path or the full name of the software. The full name includes version numbers and build names using the format: NAME/VERSION/BUILD."
arg_name "PATH"
command ['build'] do |c|
  c.desc 'Build log file name located within the software prefix.'
  c.arg_name 'FILE'
  c.default_value 'build.log'
  c.flag ["build-log-name"]

  c.desc "Disable build logging"
  c.switch ["disable-build-log"]

  c.desc 'Send messages from underlying commands (configure, make, etc) to STDOUT.'
  c.switch [:s, "send-to-stdout"]

  c.desc 'See what packages will be built but without building them'
  c.switch [:n, "dry-run"]

  c.action do |global_options,options,args|
    packages = args
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to build" if packages.empty?

    packages.each do |package|
      p = Package.new :path => package,
                :file_group => global_options[:"file-group-name"],
             :disable_group => global_options[:"disable-group-writable"],
             :software_root => global_options[:full_software_root_path]

      if p.valid?
        p.run_rebuild_script :dry_run => options[:"dry-run"],
                     :disable_logging => options[:"disable-build-log"],
                      :build_log_name => options[:"build-log-name"],
                      :send_to_stdout => options[:"send-to-stdout"]
      end
    end
  end
end

desc "Generate a new build and all necessary files"
long_desc <<-EOS
The new command will create all necessary files needed to add a new software package. Some care should be given to naming new packages. Some considerations are package names, version numbers, and build names. New package names should be of the format NAME/VERSION/BUILD

NAME of the package should be all lower case and one word. If multiple words are necessary separate them with dashes '-'.

VERSION numbers should be standard numbers separated by periods. If another format is necessary ensure that the numbers can be lexigraphically sorted in order of oldest release to newest.

BUILD names should consist of two pieces of information separated by an underscore '_', the package's intended operating system and compiler.

EXAMPLES:

silo/4.8/sles11.1_gnu4.5.3
fftw/3.2.2/cle4.0_pgi11.10.0
EOS
arg_name "NAME"
command :new do |c|
  c.desc "Create description file for website"
  c.switch ["web-description"]

  c.desc "See what files will be created when running new without creating them"
  c.switch [:n, "dry-run"]

  c.desc "Skip modulefile generation"
  c.switch ["skip-modulefile"]

  c.desc "Provide a source tarball to unpack (optional)"
  c.arg_name "FILE"
  c.flag [:t, :tarball]
  c.action do |global_options,options,args|
    raise "You must supply a name to create new packages" if args.empty?

    p = Package.new :path => args.first,
              :file_group => global_options[:"file-group-name"],
           :disable_group => global_options[:"disable-group-writable"],
           :software_root => global_options[:full_software_root_path]

    if p.valid?
      if options[:tarball]
        archive = File.absolute_path options[:tarball]
        raise "The archive #{archive} does not exist" unless File.exists? archive
      end
      p.create :dry_run => options[:"dry-run"],
                   :web => options[:"web-description"]

      p.extract :archive => archive, :dry_run => options[:"dry-run"] if options[:tarball]

      unless options[:"skip-modulefile"]
        m = ModuleFile.new :package => p
        m.create :dry_run => options[:"dry-run"]
      end
    end
  end
end

desc "Edit package support files"
arg_name "build|test|modules NAME"
command ['edit'] do |c|
  c.desc "Editor for opening script files"
  c.arg_name "BINARY"
  c.flag [:e, :editor]

  c.action do |global_options,options,args|
    editor = options[:editor] || ENV['EDITOR']
    raise """Please specify which editor to launch using the
       $EDITOR environment variable or the --editor option.""" if editor.blank?

    raise "You must supply a package name to edit" if args.empty?

    arguments = args.dup

    if arguments.include? "config"
      file_name = @smithy_config_file
      status = Kernel::system(editor, file_name)
    else

      if arguments.include? "build"
        file_name = "build"
        arguments.delete "build"
      elsif arguments.include? "test"
        file_name = "test"
        arguments.delete "test"
      elsif arguments.include?("env") || arguments.include?("modules")
        file_name = "env"
        arguments.delete "env"
      else
        file_name = "build"
      end

      p = Package.new :path => arguments.first,
                :file_group => global_options[:"file-group-name"],
             :software_root => global_options[:full_software_root_path]
      if p.valid?
        p.prefix_exists!
        p.rebuild_script_exists!

        file_name = p.rebuild_script  if file_name == "build"
        file_name = p.retest_script   if file_name == "test"
        file_name = p.remodule_script if file_name == "env"

        file_before = File.stat(file_name)
        if editor =~ /vim/
          status = Kernel::system(editor, "-O", file_name, p.remodule_script)
        elsif editor =~ /emacs/
          status = Kernel::system(editor, p.remodule_script, file_name)
        else
          status = Kernel::system(editor, file_name)
        end
        #puts status
        #puts $CHILD_STATUS

        # Compare modification times
        if status && File.stat(file_name) > file_before
          notice "Modified #{file_name}"
        end
      end

    end
  end
end

desc "Repair a package"
long_desc "Repair permissions and check that files exist"
arg_name "NAME"
command ['repair'] do |c|
  c.desc "Verify permissions only"
  c.switch [:n, "dry-run"]

  c.action do |global_options,options,args|
    packages = args
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to repair" if packages.empty?

    packages.each do |package|
      p = Package.new :path => package,
                :file_group => global_options[:"file-group-name"],
             :disable_group => global_options[:"disable-group-writable"],
             :software_root => global_options[:full_software_root_path]

      if p.valid?
        p.repair :dry_run => options[:"dry-run"]
      end
    end
  end
end

desc "Deploy a package"
long_desc "Place module files in the correct locations and update web descriptions."
arg_name "NAME"
command ['deploy'] do |c|
  c.action do |global_options,options,args|
    packages = args
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to deploy" if packages.empty?

    packages.each do |package|
      p = Package.new :path => package,
             :software_root => global_options[:full_software_root_path]
      if p.valid?
        if p.publishable?
          notice "Deploying #{p.prefix}"

          www_root = global_options.try(:[], :"web-root")
          FileUtils.mkdir_p www_root                           unless Dir.exists? www_root
          raise "Cannot access web-root directory #{www_root}" unless Dir.exists? www_root
          www_root += "/#{p.arch.downcase}"
          FileUtils.mkdir_p www_root                           unless Dir.exists? www_root
          raise "Cannot create web-root directory #{www_root}" unless Dir.exists? www_root

          description_file = File.join(p.application_directory, "description.markdown")
          description_text = ""

          begin
            if File.exist? description_file
              f = File.open description_file
              d = Maruku.new(f.read)
              description_text = d.to_html
            else
              description_file = File.join(p.application_directory, "description")
              f = File.open description_file
              description_text = f.read
            end
          rescue => exception
            raise "#{exception}\nCannot read #{description_file}"
          end

          alphabetical_output = www_root+"/alphabetical.html"
          category_output     = www_root+"/category.html"
          description_output  = www_root+"/#{p.name.downcase}.html"

          d = File.open(description_output, "w+")
          d.write(description_text)
          d.close
          puts "updated ".rjust(12).bright + description_output

          #TODO update alpha list
          #TODO update category list

          notice_success "SUCCESS #{p.qualified_name} published to web"
        else
          notice_fail "Flagged for no publishing, remove 'noweb' from #{p.exceptions_file} and re-deploy."
        end
      end
    end
  end
end

desc "Manage modulefiles for a package"
long_desc <<-EOS
smithy module create NAME/VERSION/BUILD

Generate a modulefile for a given package. This operation normally happens after creating a new package. It is provided separately here for use with existing packages

smithy module use NAME/VERSION/BUILD

Run the proper module command to add a package's modulefile to the MODULEPATH. This allows you to edit and test a modulefile in isolation. By adding the correct directory to MODULEPATH you may run module commands as you normally would.

smithy module deploy NAME/VERSION/BUILD

Copy a package's module_file to the system module path. This is typically done after you have tested a new module in isolation.

EOS
arg_name "NAME"
command ['module'] do |c|
  c.desc "See what files will be created without creating them"
  c.switch [:n, "dry-run"]
  c.action do |global_options,options,args|
    raise "You must supply a package name" if args.empty?

    arguments = args.dup
    operation = nil
    if arguments.include? "use"
      operation = :use
      arguments.delete "use"
    elsif arguments.include? "create"
      operation = :create
      arguments.delete "create"
    elsif arguments.include? "deploy"
      operation = :deploy
      arguments.delete "deploy"
    end

    p = Package.new :path => arguments.first,
             :software_root => global_options[:full_software_root_path]
    if p.valid?
      m = ModuleFile.new :package => p
      case operation
      when :use
        mp = m.module_path
        if Dir.exist?(mp)
          return "module use #{mp}"
        else
          raise "No modulefiles found in #{mp}"
        end
      when :create
        m.create :dry_run => options[:"dry-run"]
      when :deploy
        m.deploy :dry_run => options[:"dry-run"]
      end
    end
  end
end

pre do |global,command,options,args|
  # Load and merge the system config values with command line values, options on
  # the command line take precedence.
  global.merge! load_system_config(global) do |key, values_command_line, values_config|
    if values_command_line.nil?
      values_config
    else
      values_command_line
    end
  end

  Sickill::Rainbow.enabled = false if global[:"no-color"]

  # Pre logic here
  # Return true to proceed; false to abort and not call the chosen command
  # Use skips_pre before a command to skip this block on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit GLI.run(ARGV)
