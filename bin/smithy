#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end

# Absolute path to the smithy gem prefix
@@smithy_bin_root = File.expand_path(File.dirname(File.realpath(__FILE__))+ '/../')
# Add the smithy lib dir to the ruby library search path
$: << File.expand_path(@@smithy_bin_root + '/lib')

require 'rubygems'
require 'gli'
require 'English'
require 'open4'
require 'rainbow'
require 'readline'
require 'terminal-table'
require 'erb'
require 'smithy'

include GLI
include Smithy

version Smithy::VERSION

# Absolute path to the smithy config file
@smithy_config_file = File.join(@@smithy_bin_root,"etc/smithyrc")

program_desc "Smithy will help you build, test, and distribute software with ease."

desc "Machine architecure to operate on"
arg_name "NAME"
flag [:arch]

desc "Group name for files created by smithy"
arg_name "GROUP"
flag ["file-group-name"]

desc "Disable group writable file creation"
switch ["disable-group-writable"]

desc "The root level directory for software"
arg_name "PATH"
flag ["software-root"]

desc "The root level directory for web files"
arg_name "PATH"
flag ["web-root"]

desc "Don't use colors"
switch "no-color"

desc "Alternate config file (default: #{@smithy_config_file})"
arg_name "FILE"
flag [:"config-file"]

desc "Search currently installed software"
arg_name "PATTERN"
command ['search'] do |c|
  output_formats = {
    'path'  => Smithy::Format::Path.new,
    'name'  => Smithy::Format::Name.new,
    'table' => Smithy::Format::Table.new,
    'csv'   => Smithy::Format::CSV.new
  }
  c.desc 'Format of the output'
  c.arg_name output_formats.keys.join('|')
  c.default_value output_formats.keys.first
  c.flag :format

  #c.desc 'Only search packages ready for web publishing'
  #c.switch [:w, "web-enabled"]

  #sorting = %w{name date user}
  #c.desc 'Field to sort in ascending order'
  #c.arg_name sorting.join('|')
  #c.default_value sorting.first
  #c.flag :sort

  c.action do |global_options,options,args|
    swroot = global_options[:full_software_root_path]

    formatter = output_formats[options[:format]]
    raise "Unknow format \"#{options[:format]}\" valid formats include: #{output_formats.keys.join(',')}" if formatter.nil?

    notice "Searching in #{swroot}"

    software = Package.all :root => swroot

    count = 0
    formatter.before
    if args.empty?
      formatter.format(software, swroot)
      count += software.count
    else
      args.each do |a|
        result = software.select { |s| s =~ /#{a}/ }
        formatter.format(result, swroot)
        count += result.count
      end
    end
    formatter.after

    notice "#{count} Found"
  end
end

desc "Build software"
long_desc "The software to build may be either the absolute path or the full name of the software. The full name includes version numbers and build names using the format: NAME/VERSION/BUILD."
arg_name "PATH"
command ['build'] do |c|
  c.desc 'Build log file name located within the software prefix.'
  c.arg_name 'FILE'
  c.default_value 'build.log'
  c.flag ["build-log-name"]

  c.desc "Disable build logging"
  c.switch ["disable-build-log"]

  c.desc 'Send messages from underlying commands (configure, make, etc) to STDOUT.'
  c.switch [:s, "send-to-stdout"]

  c.desc 'See what packages will be built but without building them'
  c.switch [:n, "dry-run"]

  c.action do |global_options,options,args|
    packages = args.dup
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to build" if packages.empty?

    packages.each do |package|
      p = Package.new :path => package,
                :file_group => global_options[:"file-group-name"],
             :disable_group => global_options[:"disable-group-writable"],
                      :root => global_options[:full_software_root_path]

      if p.valid?
        p.run_rebuild_script :dry_run => options[:"dry-run"],
                     :disable_logging => options[:"disable-build-log"],
                      :build_log_name => options[:"build-log-name"],
                      :send_to_stdout => options[:"send-to-stdout"]
      end
    end
  end
end

desc "Generate a new build and all necessary files"
long_desc <<-EOS
The new command will create all necessary files needed to add a new software package. Some care should be given to naming new packages. Some considerations are package names, version numbers, and build names. New package names should be of the format NAME/VERSION/BUILD

NAME of the package should be all lower case and one word. If multiple words are necessary separate them with dashes '-'.

VERSION numbers should be standard numbers separated by periods. If another format is necessary ensure that the numbers can be lexigraphically sorted in order of oldest release to newest.

BUILD names should consist of two pieces of information separated by an underscore '_', the package's intended operating system and compiler.

EXAMPLES:

silo/4.8/sles11.1_gnu4.5.3
fftw/3.2.2/cle4.0_pgi11.10.0
EOS
arg_name "NAME"
command :new do |c|
  c.desc "Create description file for website"
  c.switch ["web-description"]

  c.desc "See what files will be created when running new without creating them"
  c.switch [:n, "dry-run"]

  c.desc "Skip modulefile generation"
  c.switch ["skip-modulefile"]

  c.desc "Provide a source tarball to unpack (optional)"
  c.arg_name "FILE"
  c.flag [:t, :tarball]
  c.action do |global_options,options,args|
    raise "You must supply a name to create new packages" if args.empty?

    p = Package.new :path => args.first,
              :file_group => global_options[:"file-group-name"],
           :disable_group => global_options[:"disable-group-writable"],
                    :root => global_options[:full_software_root_path]

    if p.valid?
      if options[:tarball]
        archive = File.absolute_path options[:tarball]
        raise "The archive #{archive} does not exist" unless File.exists? archive
      end
      p.create :dry_run => options[:"dry-run"],
                   :web => options[:"web-description"]

      p.extract :archive => archive, :dry_run => options[:"dry-run"] if options[:tarball]

      unless options[:"skip-modulefile"]
        m = ModuleFile.new :package => p
        m.create :dry_run => options[:"dry-run"]
      end
    end
  end
end

desc "Edit package support files"
arg_name "build|test|modules NAME"
command ['edit'] do |c|
  c.desc "Editor for opening script files"
  c.arg_name "BINARY"
  c.flag [:e, :editor]

  c.action do |global_options,options,args|
    editor = options[:editor] || ENV['EDITOR']
    raise """Please specify which editor to launch using the
       $EDITOR environment variable or the --editor option.""" if editor.blank?

    raise "You must supply a package name to edit" if args.empty?

    operations = [:build, :test, :config, :env]

    arguments = args.dup
    operation = nil
    operations.each do |o|
      if arguments.include? o.to_s
        operation = o
        arguments.delete o.to_s
        break
      end
    end

    if operation == :config
      file_name = @smithy_config_file
      status = Kernel::system(editor, file_name)
    else
      p = Package.new :path => arguments.first,
                :file_group => global_options[:"file-group-name"],
                      :root => global_options[:full_software_root_path]
      if p.valid?
        p.prefix_exists!
        p.rebuild_script_exists!

        file_name = case operation
        when :build
          p.rebuild_script
        when :test
          p.retest_script
        when :env
          p.remodule_script
        else
          p.rebuild_script
        end

        file_before = File.stat(file_name)
        if editor =~ /vim/
          if operation==:env
            status = Kernel::system(editor, file_name)
          else
            status = Kernel::system(editor, "-O", file_name, p.remodule_script)
          end
        elsif editor =~ /emacs/
          if operation==:env
            status = Kernel::system(editor, file_name)
          else
            status = Kernel::system(editor, p.remodule_script, file_name)
          end
        else
          status = Kernel::system(editor, file_name)
        end
        #puts status
        #puts $CHILD_STATUS

        # Compare modification times
        if status && File.stat(file_name) > file_before
          notice "Modified #{file_name}"
        end
      end

    end
  end
end

desc "Repair a package"
long_desc "Repair permissions and check that files exist"
arg_name "NAME"
command ['repair'] do |c|
  c.desc "Verify permissions only"
  c.switch [:n, "dry-run"]

  c.action do |global_options,options,args|
    packages = args.dup
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to repair" if packages.empty?

    packages.each do |package|
      p = Package.new :path => package,
                :file_group => global_options[:"file-group-name"],
             :disable_group => global_options[:"disable-group-writable"],
                      :root => global_options[:full_software_root_path]

      if p.valid?
        p.repair :dry_run => options[:"dry-run"]
      end
    end
  end
end

desc "Deploy a package"
long_desc "Publish packages to web"
arg_name "NAME"
command ['deploy'] do |c|
  c.desc "See what files will be created without creating them"
  c.switch [:n, "dry-run"]

  c.action do |global_options,options,args|
    swroot = global_options[:full_software_root_path]
    www_root = global_options.try(:[], :"web-root")
    raise """Cannot determine where to deploy web descriptions.\n       Please add a 'web-root: PATH' entry to the smithy config file.""" if www_root.nil?

    packages = args.dup
    if args.empty?
      notice "Reading package names from STDIN..."
      packages = STDIN.readlines.map{|p| p.chomp}
    end

    raise "You must supply at least one package to deploy" if packages.empty?

    if packages.include?("all")
      packages = Package.all_web :root => swroot
    end

    packages.each do |package|
      d = Description.new :root => swroot, :package => package, :www_root => www_root
      if d.publishable?
        notice_fail "Flagged for no publishing, remove 'noweb' from #{d.exceptions_file} and re-deploy."
      else
        d.deploy :dry_run => options[:"dry-run"]
      end
    end
  end
end

desc "Manage modulefiles for a package"
long_desc <<-EOS
smithy module create NAME/VERSION/BUILD

Generate a modulefile for a given package. This operation normally happens after creating a new package. It is provided separately here for use with existing packages

smithy module use NAME/VERSION/BUILD

Run the proper module command to add a package's modulefile to the MODULEPATH. This allows you to edit and test a modulefile in isolation. By adding the correct directory to MODULEPATH you may run module commands as you normally would.

smithy module deploy NAME/VERSION/BUILD

Copy a package's module_file to the system module path. This is typically done after you have tested a new module in isolation.
EOS
arg_name "NAME"
command ['module'] do |c|
  c.desc "See what files will be created without creating them"
  c.switch [:n, "dry-run"]
  c.action do |global_options,options,args|
    raise "You must supply a package name" if args.empty?

    operations = [:use, :create, :deploy]

    arguments = args.dup
    operation = nil
    operations.each do |o|
      if arguments.include? o.to_s
        operation = o
        arguments.delete o.to_s
        break
      end
    end

    raise "Missing module command, run 'smithy module #{operations.join("|")} NAME/VERSION/BUILD'" if operation.nil?

    p = Package.new :path => arguments.first,
                    :root => global_options[:full_software_root_path]
    if p.valid?
      m = ModuleFile.new :package => p
      case operation
      when :use
        mp = m.module_path
        if Dir.exist?(mp)
          puts "module use #{mp}"
        else
          raise "No modulefiles found in #{mp}"
        end
      when :create
        m.create :dry_run => options[:"dry-run"]
      when :deploy
        m.deploy :dry_run => options[:"dry-run"]
      end
    end
  end
end

pre do |global,command,options,args|
  # Load and merge the system config values with command line values, options on
  # the command line take precedence.
  global.merge! load_system_config(global) do |key, values_command_line, values_config|
    if values_command_line.nil?
      values_config
    else
      values_command_line
    end
  end

  Sickill::Rainbow.enabled = false if global[:"no-color"]

  # Pre logic here
  # Return true to proceed; false to abort and not call the chosen command
  # Use skips_pre before a command to skip this block on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit GLI.run(ARGV)
